// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
import * as markedschema from "marked-schema";
import * as typedschema from "ac-typed-schema";
var fs = require("fs");
import { forEach } from "p-iteration";

export async function generateAsync() {

	// First find the top-level directory
	var relativeTopDir = findRelativeTopDirectory();

	await generateHostConfigAsync(relativeTopDir);

	await generateElementsAsync(relativeTopDir);

}

async function generateHostConfigAsync(relativeTopDir: string) {

	var schemaModel = await markedschema.buildModel({
		schema: relativeTopDir + "schemas/host-config.json",
		toc: relativeTopDir + "source/nodejs/adaptivecards-site/schema-hostconfig-toc.yml",
		rootDefinition: "AdaptiveCardConfig"
	});

	var finalContents = "# Host config";

	await forEach(schemaModel, async (root: any) => {
		await forEach(root.children, async (child: any) => {

			finalContents += "\n\n## " + child.name;

			finalContents += markedschema.generateMarkdown.createPropertiesSummary(child.properties, null, true, true, child.version);
		});
	});

	await writeFileAsync(relativeTopDir + "specs/HostConfig.md", finalContents);

}

async function generateElementsAsync(relativeTopDir: string) {

	var schemaModel = await typedschema.markdown.buildModel({
		schema: relativeTopDir + "schemas/src",
		toc: relativeTopDir + "source/nodejs/adaptivecards-site/schema-explorer-toc.yml",
		rootDefinition: "AdaptiveCard",
		examplesPath: relativeTopDir + "samples/v1.*"
	});

	await forEach(schemaModel, async (root: any) => {
		await forEach(root.children, async (child: any) => {
			var type: typedschema.SchemaClass = child.type;
			var markdown = typedschema.markdown.createPropertiesSummary(type, null, true, true, child.version);

			markdown = "# " + child.name + "\n\n" + markdown;

			child.properties.forEach((prop) => {
				if (typedschema.markdown.propertyHasComplexTypes(prop)) {
					markdown += "\n\n" + typedschema.markdown.createPropertyDetails(prop, 2, null, true, true, child.version);
				}
			});

			var endAutoGeneratedTag = "<!-- END AUTO-GENERATED -->";
			markdown = "<!-- AUTO-GENERATED: This section is auto-generated from schemas/adaptive-card.json. Do NOT add anything above this or edit anything inside, it MUST be the first thing in the document and will be overwritten. -->\n\n" + markdown + endAutoGeneratedTag;

			var fileName = relativeTopDir + "specs/elements/" + child.name + ".md";
			var finalFileContents: string;
			var changed = false;

			try {

				var data = await readFileAsync(fileName, "utf8");

				var endAutoGeneratedIndex = data.indexOf(endAutoGeneratedTag);
				var currAutoGeneratedText = "";
				var currRemainingText;
				if (endAutoGeneratedIndex === -1) {
					currAutoGeneratedText = data;
				} else {
					endAutoGeneratedIndex += endAutoGeneratedTag.length;
					currAutoGeneratedText = data.substring(0, endAutoGeneratedIndex);
					currRemainingText = data.substring(endAutoGeneratedIndex);
				}

				if (markdown != currAutoGeneratedText) {
					finalFileContents = markdown + currRemainingText;
					changed = true;
				}

			} catch (err) {

				// No existing file, add on the ## Rendering header
				finalFileContents = markdown + "\n\n## Rendering";
				changed = true;

			}

			if (changed) {
				await writeFileAsync(fileName, finalFileContents);
			}
		});
	});

}

function readFileAsync(fileName: string, encoding: string): Promise<string> {
	return new Promise(function (resolve, reject) {
		fs.readFile(fileName, encoding, (err, data) => {
			if (err) {
				reject(err);
			} else {
				resolve(data);
			}
		});
	});
}

function readFile(fileName: string, encoding: string): string {
	return fs.readFileSync(fileName, encoding);
}

function writeFileAsync(fileName: string, contents: string): Promise<void> {
	return new Promise(function (resolve, reject) {
		fs.writeFile(fileName, contents, (err) => {
			if (err) {
				reject(err);
			} else {
				resolve();
			}
		})
	});
}

function writeFile(fileName: string, contents: string): void {
	fs.writeFileSync(fileName, contents);
}

function findRelativeTopDirectory(backLevels?: string): string {
	if (!backLevels) {
		backLevels = "";
	}

	try {
		fs.accessSync(backLevels + "schemas/1.2.0/adaptive-card.json");
		return backLevels;
	} catch (err) {
		if (backLevels.length > 50) {
			throw new Error("Couldn't find. Backlevels were: " + backLevels);
		} else {
			return findRelativeTopDirectory("../" + backLevels);
		}
	}
}